import { DataTypes, Model } from "sequelize";

/**
 * Document model representing files and documents in the system
 */
class Document extends Model {
  /**
   * Initialize the Document model
   * @param {Object} sequelize - Sequelize instance
   * @returns {Model} Initialized Document model
   */
  static init(sequelize) {
    return super.init(
      {
        // Primary Key
        id: {
          field: "DOCUMENT_ID",
          type: DataTypes.UUID,
          defaultValue: DataTypes.UUIDV4,
          primaryKey: true,
          comment: "Unique identifier for the document",
        },

        // References
        policyId: {
          field: "POLICY_ID",
          type: DataTypes.UUID,
          allowNull: true,
          comment: "The policy this document is associated with (if any)",
        },

        // Document Metadata
        documentType: {
          field: "DOCUMENT_TYPE",
          type: DataTypes.ENUM(
            "POLICY_DOCUMENT",
            "CERTIFICATE",
            "SCHEDULE",
            "VALUATION_SLIP",
            "CONFIRMATION_LETTER",
            "CLAIM_FORM",
            "ID_COPY",
            "PASSPORT_COPY",
            "KRA_PIN_CERTIFICATE",
            "UTILITY_BILL",
            "BANK_STATEMENT",
            "PROOF_OF_PAYMENT",
            "MEDICAL_REPORT",
            "POLICE_REPORT",
            "QUOTATION",
            "RECEIPT",
            "INVOICE",
            "OTHER"
          ),
          allowNull: false,
          comment: "Type of the document",
        },

        // File Information
        fileName: {
          field: "FILE_NAME",
          type: DataTypes.STRING(255),
          allowNull: false,
          comment: "System-generated file name for storage",
        },
        originalName: {
          field: "ORIGINAL_NAME",
          type: DataTypes.STRING(255),
          allowNull: false,
          comment: "Original file name as uploaded by user",
        },
        filePath: {
          field: "FILE_PATH",
          type: DataTypes.STRING(1000),
          allowNull: false,
          comment: "Path where the file is stored in the filesystem",
        },
        fileSize: {
          field: "FILE_SIZE",
          type: DataTypes.BIGINT,
          comment: "File size in bytes",
        },
        mimeType: {
          field: "MIME_TYPE",
          type: DataTypes.STRING(100),
          comment: "MIME type of the file",
        },
        fileHash: {
          field: "FILE_HASH",
          type: DataTypes.STRING(64),
          comment: "SHA-256 hash of the file content for integrity verification",
        },

        // Document Status
        status: {
          field: "STATUS",
          type: DataTypes.ENUM(
            "UPLOADED",
            "PROCESSING",
            "VERIFIED",
            "REJECTED",
            "EXPIRED"
          ),
          defaultValue: "UPLOADED",
          allowNull: false,
          comment: "Current status of the document",
        },

        // Document Details
        description: {
          field: "DESCRIPTION",
          type: DataTypes.TEXT,
          comment: "Optional description of the document",
        },
        isSystemGenerated: {
          field: "IS_SYSTEM_GENERATED",
          type: DataTypes.BOOLEAN,
          defaultValue: false,
          comment: "Whether the document was generated by the system",
        },

        // Audit Fields
        createdBy: {
          field: "CREATED_BY",
          type: DataTypes.UUID,
          allowNull: false,
          comment: "User who uploaded the document",
        },
        updatedBy: {
          field: "UPDATED_BY",
          type: DataTypes.UUID,
          allowNull: true,
          comment: "User who last updated the document",
        },
        verifiedBy: {
          field: "VERIFIED_BY",
          type: DataTypes.UUID,
          allowNull: true,
          comment: "User who verified the document",
        },
        verifiedAt: {
          field: "VERIFIED_AT",
          type: DataTypes.DATE,
          comment: "When the document was verified",
        },
        rejectionReason: {
          field: "REJECTION_REASON",
          type: DataTypes.TEXT,
          comment: "Reason for rejection if status is REJECTED",
        },
      },
      {
        tableName: "DOCUMENTS",
        schema: "EASYBIMA",
        timestamps: true,
        paranoid: true,
        underscored: true,
        createdAt: "CREATED_AT",
        updatedAt: "UPDATED_AT",
        deletedAt: "DELETED_AT",
        freezeTableName: true,
        sequelize,
        hooks: {
          beforeCreate: async (document) => {
            if (!document.fileName) {
              const timestamp = new Date().getTime();
              const randomString = Math.random().toString(36).substring(2, 8);
              document.fileName = `doc_${timestamp}_${randomString}`;
            }
          },
        },
        indexes: [
          {
            name: "IDX_DOCUMENTS_POLICY_ID",
            fields: ["POLICY_ID"],
          },
          {
            name: "IDX_DOCUMENTS_TYPE_STATUS",
            fields: ["DOCUMENT_TYPE", "STATUS"],
          },
        ],
      }
    );
  }

  /**
   * Define model associations
   * @param {Object} models - Object containing all models
   */
  static associate(models) {
    // Document belongs to a Policy (optional)
    this.belongsTo(models.Policy, {
      foreignKey: "POLICY_ID",
      as: "policy",
      onDelete: "SET NULL",
      onUpdate: "CASCADE",
    });

    // Document belongs to a User (creator)
    this.belongsTo(models.User, {
      foreignKey: "CREATED_BY",
      as: "creator",
      onDelete: "RESTRICT",
      onUpdate: "CASCADE",
    });

    // Document belongs to a User (verifier)
    this.belongsTo(models.User, {
      foreignKey: "VERIFIED_BY",
      as: "verifier",
      onDelete: "SET NULL",
      onUpdate: "CASCADE",
    });

    // Document belongs to a User (updater)
    this.belongsTo(models.User, {
      foreignKey: "UPDATED_BY",
      as: "updater",
      onDelete: "SET NULL",
      onUpdate: "CASCADE",
    });
  }

  /**
   * Instance method to verify the document
   * @param {string} userId - ID of the user verifying the document
   * @returns {Promise<void>}
   */
  async verify(userId) {
    this.status = "VERIFIED";
    this.verifiedAt = new Date();
    this.verifiedBy = userId;
    await this.save();
  }

  /**
   * Instance method to reject the document
   * @param {string} userId - ID of the user rejecting the document
   * @param {string} reason - Reason for rejection
   * @returns {Promise<void>}
   */
  async reject(userId, reason) {
    this.status = "REJECTED";
    this.verifiedAt = new Date();
    this.verifiedBy = userId;
    this.rejectionReason = reason;
    await this.save();
  }
}

export default Document;
